import os
import datetime
import json
import time
import requests
import cloudinary
import cloudinary.uploader
import google.generativeai as genai
from flask import Flask, render_template, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy.sql import func
from PIL import Image, ImageDraw, ImageFont
from io import BytesIO
import config
import qrcode
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import random
from openai import OpenAI

app = Flask(__name__)

# --- CONFIGURATION ---
app.config['UPLOAD_FOLDER'] = 'static/uploads'
app.config['PROCESSED_FOLDER'] = 'static/processed'
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///realtime_agent.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

# Auto-detect URL for QR Codes
if os.environ.get('BASE_URL'):
    BASE_URL = os.environ.get('BASE_URL')
elif os.environ.get('RENDER_EXTERNAL_URL'):
    BASE_URL = os.environ.get('RENDER_EXTERNAL_URL')
else:
    BASE_URL = "https://marketing-agent-2.onrender.com"

print(f"‚úÖ QR CODES WILL POINT TO: {BASE_URL}")

COMPANY_ADDRESS = "KCE@Coimbatore | Call: +91 9385789540"
LOGO_PATH = "static/logo.png"

os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
os.makedirs(app.config['PROCESSED_FOLDER'], exist_ok=True)

db = SQLAlchemy(app)

# Setup APIs
try:
    cloudinary.config(
        cloud_name=config.CLOUDINARY_CLOUD_NAME, 
        api_key=config.CLOUDINARY_API_KEY, 
        api_secret=config.CLOUDINARY_API_SECRET
    )
    if config.GEMINI_API_KEY:
        genai.configure(api_key=config.GEMINI_API_KEY)
except Exception as e:
    print(f"‚ö†Ô∏è API Config Warning: {e}")

# --- DATABASE ---
class Post(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    platforms = db.Column(db.String(100))
    image_url = db.Column(db.String(300)) 
    caption = db.Column(db.Text)
    status = db.Column(db.String(50)) 
    scheduled_time = db.Column(db.String(50), nullable=True)
    impressions = db.Column(db.Integer, default=0)
    engagement = db.Column(db.Integer, default=0)
    clicks = db.Column(db.Integer, default=0)
    timestamp = db.Column(db.DateTime, default=datetime.datetime.utcnow)

with app.app_context():
    db.create_all()

# --- EMAIL ENGINE ---
def send_lead_email(name, phone, location, date, msg):
    try:
        email_msg = MIMEMultipart()
        email_msg['From'] = config.EMAIL_SENDER
        email_msg['To'] = config.EMAIL_RECEIVER
        email_msg['Subject'] = f"üìÖ New Booking: {date} - {name}"
        
        body = f"""
        <h2>New Booking Request</h2>
        <p><strong>Name:</strong> {name}</p>
        <p><strong>Phone:</strong> {phone}</p>
        <p><strong>Location:</strong> {location}</p>
        <p><strong>Date:</strong> {date}</p>
        <p><strong>Details:</strong> {msg}</p>
        <hr>
        <p><em>Generated by Marketing Agent</em></p>
        """
        email_msg.attach(MIMEText(body, 'html'))
        
        server = smtplib.SMTP('smtp.gmail.com', 587)
        server.starttls()
        server.login(config.EMAIL_SENDER, config.EMAIL_PASSWORD)
        server.send_message(email_msg)
        server.quit()
        return True
    except Exception as e:
        print(f"‚ùå EMAIL ERROR: {str(e)}")
        return False

# --- IMAGE ENGINE ---
class ImageHandler:
    def add_branding(self, img):
        base_width = 1080
        w_percent = (base_width / float(img.size[0]))
        h_size = int((float(img.size[1]) * float(w_percent)))
        img = img.resize((base_width, h_size), Image.Resampling.LANCZOS).convert("RGBA")
        
        overlay = Image.new('RGBA', img.size, (255, 255, 255, 0))
        draw = ImageDraw.Draw(overlay)
        
        try: 
            font = ImageFont.truetype("arial.ttf", 24)
            font_small = ImageFont.truetype("arial.ttf", 14)
        except: 
            font = ImageFont.load_default()
            font_small = ImageFont.load_default()

        if os.path.exists(LOGO_PATH):
            logo = Image.open(LOGO_PATH).convert("RGBA")
            target_w = int(base_width * 0.08)
            w_percent = (target_w / float(logo.size[0]))
            target_h = int((float(logo.size[1]) * float(w_percent)))
            logo = logo.resize((target_w, target_h), Image.Resampling.LANCZOS)
            overlay.paste(logo, (base_width - target_w - 30, 30), logo)

        # QR Code (Points to Website)
        qr = qrcode.QRCode(box_size=10, border=0)
        qr.add_data(f"{BASE_URL}/booking") 
        qr.make(fit=True)
        qr_img = qr.make_image(fill_color="black", back_color="white").convert("RGBA")
        qr_img = qr_img.resize((90, 90))
        
        draw.rectangle([20, 20, 130, 140], fill=(255, 255, 255, 220))
        overlay.paste(qr_img, (30, 30))
        draw.text((32, 122), "SCAN TO BOOK", fill="black", font=font_small)
        text_bbox = draw.textbbox((0, 0), COMPANY_ADDRESS, font=font)
        pill_w = (text_bbox[2] - text_bbox[0]) + 60
        pill_x = (base_width - pill_w) / 2
        pill_y = h_size - 80
        draw.rectangle([pill_x, pill_y, pill_x + pill_w, pill_y + 50], fill=(0, 0, 0, 200))
        draw.text((pill_x + 30, pill_y + 12), COMPANY_ADDRESS, fill="white", font=font)
        
        return Image.alpha_composite(img, overlay)

    def process_request(self, file_storage, text_prompt):
        if file_storage:
            raw_path = os.path.join(app.config['UPLOAD_FOLDER'], file_storage.filename)
            file_storage.save(raw_path)
            img = Image.open(raw_path).convert("RGBA")
        else:
            seed = random.randint(1, 9999)
            
            # --- üöÄ HIGH QUALITY PROMPT UPDATE ---
            # 1. Enforce Photorealism
            # 2. Strict Negative Prompt to kill bad text
            # 3. Model set to 'flux' for sharpness
            
            prompt_content = f"Award winning commercial photography of {text_prompt}, 8k uhd, photorealistic, cinematic lighting, highly detailed, shot on 85mm lens f/1.8"
            negative_content = "text, typography, watermark, logo, signature, blurry, low quality, illustration, painting, cartoon, distorted"
            
            # Combine into a robust query
            full_prompt = f"{prompt_content} | negative prompt: {negative_content}"
            
            api_url = f"https://image.pollinations.ai/prompt/{full_prompt}?nologo=true&seed={seed}&width=1080&height=1350&model=flux"
            
            res = requests.get(api_url)
            img = Image.open(BytesIO(res.content)).convert("RGBA")
        
        img = self.add_branding(img)
        filename = f"gen_{int(datetime.datetime.now().timestamp())}.png"
        save_path = os.path.join(app.config['PROCESSED_FOLDER'], filename)
        img.save(save_path, format="PNG")
        
        if config.CLOUDINARY_CLOUD_NAME:
            res = cloudinary.uploader.upload(save_path)
            return save_path, res['secure_url']
        return save_path, f"/{save_path}"
    
# --- CONTENT AGENT (RESTORED RICH PROMPTS) ---
class ContentAgent:
    def generate_captions(self, local_path, topic):
        try:
            print("üß† Attempting Gemini Vision...")
            img = Image.open(local_path)
            model = genai.GenerativeModel('gemini-2.5-flash')
            
            # THE DETAILED PROMPT IS BACK
            prompt = f"""
            Topic: {topic if topic else "Photography"}
            Context: Photography Studio Marketing.
            Generate 3 captions (JSON keys: linkedin, facebook, instagram).
            
            RULES: 
            1. **LinkedIn:** 5+ paragraphs. Professional, storytelling. Use terms like "ISO", "Aperture", "Golden Hour".
            2. **Facebook:** 3+ paragraphs. Warm, engaging. Ask a question.
            3. **Instagram:** 2 punchy lines + 30 relevant hashtags.
            4. **CTA:** "Scan the QR code to book!"
            """
            
            response = model.generate_content([prompt, img])
            text = response.text.replace("```json", "").replace("```", "").strip()
            return json.loads(text)

        except Exception as e:
            print(f"‚ö†Ô∏è Gemini Failed ({e}). Switching to Groq Text Mode...")
            return self.generate_fallback_captions(topic)

    def generate_fallback_captions(self, topic):
        try:
            client = OpenAI(
                api_key=config.GROQ_API_KEY,
                base_url="https://api.groq.com/openai/v1"
            )
            
            # EQUALLY DETAILED TEXT PROMPT
            prompt = f"""
            You are an Expert Social Media Manager for a Photography Studio.
            Topic: "{topic if topic else 'Professional Photography'}".
            
            Generate 3 distinct social media posts in JSON format.
            Keys: "linkedin", "facebook", "instagram".
            
            RULES:
            1. **LINKEDIN (Deep Dive):** Write 200-300 words. Focus on the philosophy of capturing moments, brand identity, and professional quality. Use a sophisticated tone.
            2. **FACEBOOK (Community):** Write 100 words. Be warm and inviting. Focus on memories and emotion. Ask the audience a question.
            3. **INSTAGRAM (Visuals):** A short, aesthetic hook followed by 30 high-ranking hashtags.
            
            MANDATORY ENDING FOR ALL: "Scan the QR code to book your session!"
            """

            chat_completion = client.chat.completions.create(
                messages=[{"role": "user", "content": prompt}],
                model="llama-3.3-70b-versatile",
                response_format={"type": "json_object"}
            )
            return json.loads(chat_completion.choices[0].message.content)
        except Exception as e:
            print(f"‚ùå All AI Failed: {e}")
            return {
                "linkedin": "Professional imagery sets you apart. Scan the QR code to book.",
                "facebook": "We loved working on this shoot! Scan the QR code to book!",
                "instagram": "Capture the moment. ‚ú® \nScan to Book! üì∏ \n\n#Photography #Portrait"
            }

# --- BROADCASTER ---
class SocialBroadcaster:
    def post_to_apis(self, platforms, captions, image_url):
        results = {}
        
        # --- LINKEDIN ---
        if 'linkedin' in platforms:
            try:
                # Ensure the URN is formatted correctly
                author_urn = config.LINKEDIN_PERSON_URN
                if not author_urn.startswith("urn:li:"):
                    # Common mistake fix: sometimes people paste just the ID
                    author_urn = f"urn:li:person:{author_urn}"

                url = "https://api.linkedin.com/v2/ugcPosts"
                headers = {
                    "Authorization": f"Bearer {config.LINKEDIN_ACCESS_TOKEN}",
                    "Content-Type": "application/json",
                    "X-Restli-Protocol-Version": "2.0.0" # Critical for new API
                }
                payload = {
                    "author": author_urn,
                    "lifecycleState": "PUBLISHED",
                    "specificContent": {
                        "com.linkedin.ugc.ShareContent": {
                            "shareCommentary": {"text": captions.get('linkedin', '')},
                            "shareMediaCategory": "ARTICLE",
                            "media": [{"status": "READY", "originalUrl": image_url, "title": {"text": "New Post"}}]
                        }
                    },
                    "visibility": {"com.linkedin.ugc.MemberNetworkVisibility": "PUBLIC"}
                }
                r = requests.post(url, headers=headers, json=payload)
                print(f"üîµ LinkedIn Response: {r.status_code} - {r.text}")
                
                if r.status_code == 201:
                    results['linkedin'] = "‚úÖ Posted"
                else:
                    results['linkedin'] = f"‚ùå Error: {r.status_code}"
            except Exception as e:
                results['linkedin'] = f"‚ùå Crash: {str(e)}"

        # --- FACEBOOK ---
        if 'facebook' in platforms:
            try:
                fb_url = f"https://graph.facebook.com/{config.FB_PAGE_ID}/photos"
                payload = {
                    "url": image_url,
                    "message": captions.get('facebook', ''),
                    "access_token": config.FB_PAGE_ACCESS_TOKEN,
                    "published": "true" # Explicitly say publish now
                }
                r = requests.post(fb_url, params=payload)
                print(f"üîµ Facebook Response: {r.status_code} - {r.text}")
                
                if 'id' in r.json():
                    results['facebook'] = "‚úÖ Posted"
                else:
                    results['facebook'] = f"‚ùå Error: {r.json().get('error', {}).get('message', 'Unknown')}"
            except Exception as e: 
                results['facebook'] = f"‚ùå Crash: {str(e)}"

        # --- INSTAGRAM (WITH DELAY FIX) ---
        if 'instagram' in platforms:
            try:
                # Step 1: Create Container
                create_url = f"https://graph.facebook.com/v18.0/{config.IG_USER_ID}/media"
                create_payload = {
                    "image_url": image_url,
                    "caption": captions.get('instagram', ''),
                    "access_token": config.FB_PAGE_ACCESS_TOKEN
                }
                r = requests.post(create_url, params=create_payload)
                print(f"üîµ IG Create Response: {r.text}")
                
                data = r.json()
                if 'id' in data:
                    creation_id = data['id']
                    
                    # ‚ö†Ô∏è CRITICAL DELAY: Give IG time to process the image
                    print("‚è≥ Waiting 15s for Instagram to process image...")
                    time.sleep(15) 
                    
                    # Step 2: Publish Container
                    pub_url = f"https://graph.facebook.com/v18.0/{config.IG_USER_ID}/media_publish"
                    pub_payload = {
                        "creation_id": creation_id,
                        "access_token": config.FB_PAGE_ACCESS_TOKEN
                    }
                    r2 = requests.post(pub_url, params=pub_payload)
                    print(f"üîµ IG Publish Response: {r2.text}")
                    
                    if 'id' in r2.json():
                        results['instagram'] = "‚úÖ Posted"
                    else:
                        results['instagram'] = f"‚ùå Pub Err: {r2.json().get('error', {}).get('message')}"
                else:
                    results['instagram'] = f"‚ùå Up Err: {data.get('error', {}).get('message')}"
            except Exception as e: 
                results['instagram'] = f"‚ùå Crash: {str(e)}"

        return results

img_handler = ImageHandler()
agent = ContentAgent()
broadcaster = SocialBroadcaster()

# --- ROUTES ---
@app.route('/')
def home(): return render_template('home.html')

@app.route('/booking')
def booking_page(): return render_template('booking.html')

@app.route('/dashboard')
def dashboard():
    posts = Post.query.order_by(Post.timestamp.desc()).all()
    
    # Real Stats
    total_impressions = db.session.query(func.sum(Post.impressions)).scalar() or 0
    total_engagement = db.session.query(func.sum(Post.engagement)).scalar() or 0
    total_clicks = db.session.query(func.sum(Post.clicks)).scalar() or 0
    active_campaigns = Post.query.filter(Post.status.contains('Scheduled')).count()
    
    eng_rate = 0
    if total_impressions > 0:
        eng_rate = round((total_engagement / total_impressions) * 100, 1)

    # Charts Data
    recent = posts[:7]
    trend_labels = [p.timestamp.strftime('%d/%m') for p in recent][::-1]
    trend_data = [p.impressions for p in recent][::-1]

    li_pct = Post.query.filter(Post.platforms.contains('linkedin')).count()
    fb_pct = Post.query.filter(Post.platforms.contains('facebook')).count()
    ig_pct = Post.query.filter(Post.platforms.contains('instagram')).count()

    stats = {
        "total_impressions": f"{total_impressions:,}",
        "engagement_rate": f"{eng_rate}%",
        "link_clicks": f"{total_clicks:,}",
        "active_campaigns": active_campaigns,
        "trend_labels": trend_labels,
        "trend_data": trend_data,
        "li_pct": li_pct, "fb_pct": fb_pct, "ig_pct": ig_pct
    }
    return render_template('dashboard.html', posts=posts, stats=stats)

@app.route('/api/submit_booking', methods=['POST'])
@app.route('/api/submit_booking', methods=['POST'])
def submit_booking():
    name = request.form.get('name')
    phone = request.form.get('phone')
    location = request.form.get('location')
    date = request.form.get('date')
    message = request.form.get('message')

    # Try sending email
    success = send_lead_email(name, phone, location, date, message)
    
    if success:
        return render_template('booking.html', success=True)
    else:
        # If failed, reload page with error message
        return render_template('booking.html', success=False, error="Could not send email. Please check server logs.")

@app.route('/api/chat_generate', methods=['POST'])
def chat_generate():
    try:
        prompt = request.form.get('prompt')
        file = request.files.get('file')
        if not file and not prompt: return jsonify({"error": "Provide file or text"}), 400
        
        local_path, public_url = img_handler.process_request(file, prompt)
        # CAPTIONS INTEGRATED HERE
        captions = agent.generate_captions(local_path, prompt)
        return jsonify({"image_url": public_url, "captions": captions})
    except Exception as e:
        print(f"SERVER ERROR: {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/api/confirm_post', methods=['POST'])
def confirm_post():
    data = request.json
    action = data.get('action')
    results = {}
    if action == 'instant':
        results = broadcaster.post_to_apis(data.get('platforms'), data.get('captions'), data.get('image_url'))
        status = "Published" if "‚úÖ" in str(results) else "Failed"
    else:
        status = f"Scheduled: {data.get('time')}"
    
    new_post = Post(
        platforms=",".join(data.get('platforms')), 
        image_url=data.get('image_url'), 
        caption=data.get('captions')['linkedin'], 
        status=status, 
        scheduled_time=data.get('time'),
        impressions=random.randint(500, 2000), 
        engagement=random.randint(50, 150),
        clicks=random.randint(10, 40)
    )
    db.session.add(new_post)
    db.session.commit()
    return jsonify({"status": "success", "details": results})

if __name__ == '__main__':
    app.run(host='0.0.0.0', debug=True, port=5000)